<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Cristian Planas]]></title>
  <link href="http://Gawyn.github.com/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://Gawyn.github.com/"/>
  <updated>2013-12-09T23:39:13+01:00</updated>
  <id>http://Gawyn.github.com/</id>
  <author>
    <name><![CDATA[Cristian Planas]]></name>
    <email><![CDATA[me@cristianplanas.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[The Black Magic of Ruby Metaprogramming]]></title>
    <link href="http://Gawyn.github.com/blog/2013/10/27/the-black-magic-of-ruby-metaprogramming/"/>
    <updated>2013-10-27T22:46:00+01:00</updated>
    <id>http://Gawyn.github.com/blog/2013/10/27/the-black-magic-of-ruby-metaprogramming</id>
    <content type="html"><![CDATA[<p>Last Friday I gave another talk at the accelerator Itnig's offices. After presenting about <a href="http://cristianplanas.com/blog/2013/01/14/one-graph-to-rule-them-all/">growth hacking and Facebook</a>, this time I went more technical. I explained one of the most interesting concepts in Ruby: metaprogramming.</p>

<p>Using the story of The Sorcerer's Apprentice -the one with Mickey Mouse, not the one with Nicholas Cage-, I explain what is metaprogramming, the most common techniques and some of its dangers.</p>

<p><div class="embed-responsive-container"><iframe src="http://www.slideshare.net/slideshow/embed_code/27655078 "></iframe></div></p>

<p>You can also watch the presentation in video:</p>

<p><div class="embed-responsive-container"><iframe src="http://player.vimeo.com/video/79437180 "></iframe></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A picture with Matz]]></title>
    <link href="http://Gawyn.github.com/blog/2013/09/22/a-picture-with-matz/"/>
    <updated>2013-09-22T22:08:00+02:00</updated>
    <id>http://Gawyn.github.com/blog/2013/09/22/a-picture-with-matz</id>
    <content type="html"><![CDATA[<p><img class="center" src="https://s3-eu-west-1.amazonaws.com/cristianplanas-blog/me-and-matz.jpg" title="A picture with Matz" alt="A picture with Matz at the BaRuCo 2013"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BaRuCo 2012 review]]></title>
    <link href="http://Gawyn.github.com/blog/2012/09/11/baruco-2012-review/"/>
    <updated>2012-09-11T15:56:00+02:00</updated>
    <id>http://Gawyn.github.com/blog/2012/09/11/baruco-2012-review</id>
    <content type="html"><![CDATA[<p>Last weekend I was able to assist to the <a href="http://www.baruco.org/">Barcelona Ruby Conference</a>, organized by our friends of <a href="http://www.codegram.com/">Codegram</a>. The list of speakers looked very promising and the event didn’t disappoint anyone.</p>

<p>First of all it's important to remark how amazing the organization was: all the attendants were really well treated. In the picture below, you can see the delicious breakfast that we were able to enjoy just before the first speakers started:</p>

<p><a href="http://tweetmovies.net"><img class="center" src="https://s3-eu-west-1.amazonaws.com/cristianplanas-blog/baruco_breakfast.jpg" title="Breakfast at BaRuCo" alt="A delicious breakfast for the BaRuCo attendants"></a></p>

<p>But the main point in any conference is the quality of the talks, and BaRuCo speakers did a real good job: the quantity of the talks was small compared to other conferences, but most of them were really interesting. Some of them were slightly too technical for the audience who approaches for the first time the topic that is exposed, but most of them found the perfect middleground between depth and simplicity. However, there were some that stood out...</p>

<ul>
<li><p><strong>Bronze medal for...</strong>: <em>Programming workout</em> by Michal Taszycki. A description of how to get from beginner to master in any discipline, with some useful techniques for improving in any area. I really like this kind of talks with a broader, more humanistic scope.</p></li>
<li><p><strong>Silver medal for...</strong>: <em>Micro-Service Architecture</em> by Fred George. I already praised in this blog <a href="/blog/2012/02/05/programmer-anarchy/">another awesome talk given by Mr. George</a>: he is a really gifted speaker. This time, he exposed how his company faced some difficult cases dividing the architecture in multiple applications, managing to reduce the complexity of the solution.</p></li>
<li><p><strong>Gold medal for...</strong>: <em>Why Agile (A short history of software engineering, and other ideas that didn’t work)</em> by Paolo Perrotta: I was a big fan of Mr. Perrotta since I read Metaprogramming Ruby, a book which changed the way I understand developing; but now… fuck, everybody in the congress fell in love with him. He stole the show with a great and very funny talk about how the own concept of software engineering is a misunderstanding of our craft.</p></li>
</ul>


<p>Summarizing, looks like that Barcelona has a new you-can't-miss-it event. We are already waiting for 2013 tickets.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The beauty of Ruby conditionals]]></title>
    <link href="http://Gawyn.github.com/blog/2012/02/16/the-beauty-of-ruby-conditionals/"/>
    <updated>2012-02-16T01:15:00+01:00</updated>
    <id>http://Gawyn.github.com/blog/2012/02/16/the-beauty-of-ruby-conditionals</id>
    <content type="html"><![CDATA[<p>Conditionals define the way in which a language specifies its logic. With
this, they not only define the way you are going to code: they are also
stating what you can do, and the way you are going to think and feel about your
applications. As I said in other entries, imagination is essential for a
good developer, and for having a free imagination, a simple and flexible
language -with its simple and flexible conditionals- is absolutely
required.</p>

<p>In this, Ruby also stands out. Developers not only are able to use the
usual if and else idioms, but count with some nice additions.</p>

<ul>
<li><strong>Improving negative conditions</strong></li>
</ul>


<p>In any kind of code, negative conditions are used quite often: and the
<code>if not</code> idiom is not natural at all. Ruby provides of an specific idiom
to state a negative condition: <code>unless</code>. For example, this:</p>

<pre><code>if array.length != 1
</code></pre>

<p>looks much more nice like this:</p>

<pre><code>unless array.length == 1
</code></pre>

<p>This also has its counterpart in loops, as until is the opposite of while.</p>

<ul>
<li><strong>Ruby is an easy-going guy</strong></li>
</ul>


<p>And thinks that most of the time people are saying the truth. So when
Ruby evaluates a variable as a condition, everything except nil and
false will be passed as true. That has some interesting effects:</p>

<pre><code>if 0 puts 'C developers, 0 is true in Ruby!'
</code></pre>

<ul>
<li><strong>Moving the condition to the end</strong></li>
</ul>


<p>Ruby always try to be as readable as possible, so it adds a new way to
define a condition: leaving it after the actual code. For example,
following the example given before:</p>

<pre><code>puts 'C developers, 0 is true in Ruby!' if 0
</code></pre>

<ul>
<li><strong>Conditions are executed in order</strong></li>
</ul>


<p>That's a great help. For example, imagine we have this code:</p>

<pre><code>puts "The length is 2" unless a.nil? || a.length == 2
</code></pre>

<p>In the case that a is nil, in other languages we would have an
exception, as the nil element doesn't have any method called length. But
Ruby is smart enough to know that in an OR you don't need to evaluate
the other conditions if one is true.</p>

<ul>
<li><strong>The nil guard</strong></li>
</ul>


<p>When a Ruby beginners faces a piece of code, the most exotic idiom he
can find will probably this: ||=. This is called the nil guard. It comes
to save a typical problem: an assignation that only should be executed
when the variable assigned is nil.</p>

<pre><code>a ||= []
</code></pre>

<p>that's much better than</p>

<pre><code>a = [] if a.nil?
</code></pre>

<p>it's just more elegant. As you can see, the nil guard is related with
the executing the conditionals in order thing.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why do I love method_missing]]></title>
    <link href="http://Gawyn.github.com/blog/2012/01/29/why-do-i-love-method-missing/"/>
    <updated>2012-01-29T17:27:00+01:00</updated>
    <id>http://Gawyn.github.com/blog/2012/01/29/why-do-i-love-method-missing</id>
    <content type="html"><![CDATA[<p>Every Ruby developer has some tricks that he loves. Sometimes it's not even necessary to use them a lot: it's enough if you like them only in a philosophical or aesthetical way. When you talk about Ruby to a newcomer, the first thing you do is to give an enthusiastic description about that technique, your favourite one. And for me, I guess it's <code>method_missing</code>.</p>

<h2>What is <code>method_missing</code>?</h2>

<p>I discovered method_missing in a great Ruby book: <em>Metaprogramming Ruby</em> by Paolo Perrotta. Originally, <em>method_missing</em> is a function that is only called when Ruby can't find a given method into an object. If the object is the last in the jerarchy (in 1.9, BasicObject), <code>method_missing</code> raises an error; if not, it calls the same method in the inmediate superior object in the jerarchy.</p>

<h2>Oh, a method to raise an error. And why should I care?</h2>

<p>Because remember, in Ruby you can redefine methods as you like. With that feature, <code>method_missing</code> becomes the ultimate hook: you can intercept literally every action (that doesn't have a method defined yet)) and treat it as you wish. For example, let's make that everytime we call <code>write_{#something}</code>, Ruby writes it:</p>

<pre><code>def method_missing(method, *args)
  method_name = method.to_s
  if method_name.start_with?('write_')
    puts method_name[6..-1]
  else puts 'This method does not exist here'
  end
end
</code></pre>

<h2>That sounds like quite weird (and useless) stuff...</h2>

<p>Maybe, but it's in the core of some of Ruby most popular gems, like (guess) Rails. Have your ever thought how some ActiveRecords methods like <code>find_by_#{attribute}</code> work? You are right, thanks to <code>method_missing</code>.</p>

<p>Actually, ActiveRecords combines <code>method_missing</code> with another great metaprogramming technique: dynamic methods. The first time you call a reader or writer method in an object of a given class, those methods are not still defined: then <code>method_missing</code> appears, defining the actions for each of the table columns. Clever, elegant and really, really useful.</p>

<h2>Whoa, now it sounds cool. Which are its flaws?</h2>

<p>It doesn't sound cool, <strong>it is cool</strong>. But OK, it has some flaws. As with some other metaprogramming techniques, one is tempted to use them constantly, even when there isn't any reason to use it over dynamic methods or even normal vanilla methods. And those are much better in terms of cost.</p>

<p>Another big flaw: it's hard as hell to debug. In the end, we are "hacking" an error method, and one of the most basic ones.</p>

<h2>OK, now I see the pros and the cons. But why do you like it so much?</h2>

<p>As I told in the beginning, it's a philosophical matter. <code>method_missing</code> ilustrates perfectly those famous words by Matz:</p>

<blockquote><p>Ruby trusts you. Ruby treats you as a grown-up programmer. It gives you great power such as meta-programming. But you need to remember that with great power comes great responsibility.</p></blockquote>

<p>To be able to wait in the backdoor for those treacherous method calls and giving them a good beating -I mean, dealing with them- it really changed my concept of software development. And I guess that is why I like <code>method_missing</code>. Exactly the same reason that makes me love Ruby.</p>
]]></content>
  </entry>
  
</feed>
